import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from bson import ObjectId
from motor.motor_asyncio import AsyncIOMotorCollection
from app.crud.webhooks_crud import WebhooksCrud
from app.utils.common import convert_objectid_to_str, validate_object_id
from fastapi import HTTPException


# ------------------ MOCK COLLECTION FIXTURE ------------------


@pytest.fixture
def mock_collection():
    """Mocked Mongo collection for webhooks with correct async behavior."""
    collection = MagicMock(spec=AsyncIOMotorCollection)

    collection.insert_one = AsyncMock()
    collection.find_one = AsyncMock(return_value=None)
    collection.update_one = AsyncMock()
    collection.count_documents = AsyncMock(return_value=0)

    # Mock cursor for find()
    cursor = MagicMock()
    cursor.skip.return_value = cursor
    cursor.limit.return_value = cursor
    cursor.__aiter__.return_value = iter([]) # Default to empty iterator for async for loops
    cursor.to_list = AsyncMock(return_value=[])

    collection.find.return_value = cursor

    return collection


@pytest.fixture
def crud(mock_collection):
    return WebhooksCrud(mock_collection)


@pytest.fixture
def dummy_webhook_data():
    return {
        "_id": ObjectId("60d0fe4f3460595e63456789"),
        "url": "https://example.com/webhook",
        "df_id": "df123",
        "events": ["data_fiduciary.created", "user.updated"],
        "status": "active",
        "secret": "supersecret",
    }


# ------------------ TESTS ------------------


@pytest.mark.asyncio
async def test_create_webhook(crud, mock_collection, dummy_webhook_data):
    inserted_id = ObjectId("60d0fe4f3460595e63456789")
    mock_collection.insert_one.return_value = MagicMock(inserted_id=inserted_id)

    webhook_data_to_create = dummy_webhook_data.copy()
    del webhook_data_to_create["_id"] # _id is generated by MongoDB

    result = await crud.create_webhook(webhook_data_to_create)

    mock_collection.insert_one.assert_called_once_with(webhook_data_to_create)
    assert result == str(inserted_id)


@pytest.mark.asyncio
async def test_get_webhook_by_url_and_df(crud, mock_collection, dummy_webhook_data):
    mock_collection.find_one.return_value = dummy_webhook_data.copy()
    url = dummy_webhook_data["url"]
    df_id = dummy_webhook_data["df_id"]

    result = await crud.get_webhook_by_url_and_df(url, df_id)

    mock_collection.find_one.assert_called_once_with(
        {"url": url, "df_id": df_id, "status": {"$ne": "archived"}}
    )
    assert result == dummy_webhook_data


@pytest.mark.asyncio
@pytest.mark.parametrize(
    "webhook_id_input, find_one_return, expected_result_is_none, expects_exception",
    [
        ("60d0fe4f3460595e63456789", {"_id": ObjectId("60d0fe4f3460595e63456789"), "url": "test_url"}, False, False),
        ("invalid_id", None, True, True), # Invalid ID, should raise HTTPException due to validate_object_id
        ("60d0fe4f3460595e63456781", None, True, False),
    ],
)
@patch("app.crud.webhooks_crud.validate_object_id")
async def test_get_webhook(
    mock_validate_object_id, crud, mock_collection, dummy_webhook_data,
    webhook_id_input, find_one_return, expected_result_is_none, expects_exception
):
    if expects_exception:
        mock_validate_object_id.side_effect = HTTPException(status_code=422, detail="Invalid ObjectId format")
        with pytest.raises(HTTPException):
            await crud.get_webhook(webhook_id_input, dummy_webhook_data["df_id"])
        mock_validate_object_id.assert_called_once_with(webhook_id_input)
        mock_collection.find_one.assert_not_called()
        return

    # For valid IDs or where no exception is expected
    mock_validate_object_id.return_value = ObjectId(webhook_id_input) if ObjectId.is_valid(webhook_id_input) else None
    mock_collection.find_one.return_value = find_one_return
        
    result = await crud.get_webhook(webhook_id_input, dummy_webhook_data["df_id"])

    mock_validate_object_id.assert_called_once_with(webhook_id_input)
    if ObjectId.is_valid(webhook_id_input):
        mock_collection.find_one.assert_called_once_with(
            {"_id": ObjectId(webhook_id_input), "df_id": dummy_webhook_data["df_id"], "status": {"$ne": "archived"}}
        )
    else:
        mock_collection.find_one.assert_not_called()

    if expected_result_is_none:
        assert result is None
    else:
        assert result == convert_objectid_to_str(find_one_return)


@pytest.mark.asyncio
async def test_list_all_webhooks_by_df(crud, mock_collection, dummy_webhook_data):
    webhook_doc_1 = {**dummy_webhook_data, "_id": ObjectId("60d0fe4f3460595e63456789"), "status": "active"}
    webhook_doc_2 = {**dummy_webhook_data, "_id": ObjectId("60d0fe4f3460595e6345678a"), "status": "active", "url": "https://example.com/another"}

    mock_collection.find.return_value.__aiter__.return_value = iter([webhook_doc_1.copy(), webhook_doc_2.copy()])

    df_id = dummy_webhook_data["df_id"]
    result = await crud.list_all_webhooks_by_df(df_id)

    mock_collection.find.assert_called_once_with({"df_id": df_id, "status": {"$ne": "archived"}})
    assert len(result) == 2
    assert result[0] == convert_objectid_to_str(webhook_doc_1)
    assert result[1] == convert_objectid_to_str(webhook_doc_2)


@pytest.mark.asyncio
async def test_list_webhooks_by_df(crud, mock_collection, dummy_webhook_data):
    webhook_doc_1 = {**dummy_webhook_data, "_id": ObjectId("60d0fe4f3460595e63456789"), "status": "active"}
    webhook_doc_2 = {**dummy_webhook_data, "_id": ObjectId("60d0fe4f3460595e6345678a"), "status": "active", "url": "https://example.com/paginated"}

    mock_collection.count_documents.return_value = 2
    mock_collection.find.return_value.__aiter__.return_value = iter([webhook_doc_1.copy(), webhook_doc_2.copy()])

    df_id = dummy_webhook_data["df_id"]
    offset = 0
    limit = 10

    result = await crud.list_webhooks_by_df(df_id, offset, limit)

    query = {"df_id": df_id, "status": {"$ne": "archived"}}
    mock_collection.count_documents.assert_called_once_with(query)
    mock_collection.find.assert_called_once_with(query)
    mock_collection.find.return_value.skip.assert_called_once_with(offset)
    mock_collection.find.return_value.limit.assert_called_once_with(limit)
    assert result["total"] == 2
    assert len(result["data"]) == 2
    assert result["data"][0] == convert_objectid_to_str(webhook_doc_1)
    assert result["data"][1] == convert_objectid_to_str(webhook_doc_2)


@pytest.mark.asyncio
@pytest.mark.parametrize(
    "webhook_id_input, update_one_matched_count, update_data, find_one_return, expected_result_is_none, expects_exception",
    [
        (
            "60d0fe4f3460595e63456789", 1, {"status": "inactive"}, 
            {"_id": ObjectId("60d0fe4f3460595e63456789"), "url": "updated.com", "status": "inactive"}, 
            False, False
        ),
        ("invalid_id", 0, {"status": "inactive"}, None, True, True), # Invalid ID, should raise HTTPException
        ("60d0fe4f3460595e63456781", 0, {"status": "inactive"}, None, True, False), # Valid ID, but not found, should return None
    ],
)
@patch("app.crud.webhooks_crud.validate_object_id")
async def test_update_webhook(
    mock_validate_object_id, crud, mock_collection, dummy_webhook_data,
    webhook_id_input, update_one_matched_count, update_data, find_one_return,
    expected_result_is_none, expects_exception
):
    if expects_exception:
        mock_validate_object_id.side_effect = HTTPException(status_code=422, detail="Invalid ObjectId format")
        with pytest.raises(HTTPException):
            await crud.update_webhook(webhook_id_input, update_data)
        mock_validate_object_id.assert_called_once_with(webhook_id_input)
        mock_collection.update_one.assert_not_called()
        mock_collection.find_one.assert_not_called()
        return

    mock_validate_object_id.return_value = ObjectId(webhook_id_input) if ObjectId.is_valid(webhook_id_input) else None
    mock_collection.update_one.return_value = MagicMock(matched_count=update_one_matched_count, modified_count=1)
    mock_collection.find_one.return_value = find_one_return

    result = await crud.update_webhook(webhook_id_input, update_data)

    mock_validate_object_id.assert_called_once_with(webhook_id_input)
    if ObjectId.is_valid(webhook_id_input):
        mock_collection.update_one.assert_called_once_with(
            {"_id": ObjectId(webhook_id_input)}, {"$set": update_data}
        )
        # find_one is always called in the crud method after update_one
        mock_collection.find_one.assert_called_once_with({"_id": ObjectId(webhook_id_input)})
    else:
        mock_collection.update_one.assert_not_called()
        mock_collection.find_one.assert_not_called()

    if expected_result_is_none:
        assert result is None
    else:
        assert result == convert_objectid_to_str(find_one_return)


@pytest.mark.asyncio
@pytest.mark.parametrize(
    "modified_count, expected_return",
    [
        (1, True),
        (0, False),
    ],
)
async def test_delete_webhook(crud, mock_collection, modified_count, expected_return):
    webhook_id = "60d0fe4f3460595e63456789"
    mock_collection.update_one.return_value = MagicMock(matched_count=1, modified_count=modified_count)

    result = await crud.delete_webhook(webhook_id)

    mock_collection.update_one.assert_called_once_with(
        {"_id": ObjectId(webhook_id)},
        {"$set": {"status": "archived"}},
    )
    assert result == expected_return
